-- Project Lift System SOFTENG 751 - 5/10/2019
-- Written by Buster Major and Nathan Cairns

model LiftSystem

---- CLASSES ----

enum FloorButtonDirection {up, down}
enum Movement {upward, downward, idle}

class Building
attributes
    fireAlarm : Boolean
operations
    minDistance() : Integer -- TODO: remove
    liftTick()
    engageFireAlarm()
    disengageFireAlarm()
end

class Floor
attributes
    level : Integer
    label : String
    buttons: Set(FloorButtonDirection)
    waitingFor: Movement
operations
    pressFloorButton(direction : FloorButtonDirection)
end

class Lift
attributes
    level : Integer
    doorsClosed : Boolean
    jobMovement : Movement
    physicalMovement : Movement
    jobs : Set(Floor)
    lockDoor : Boolean
    movementLocked : Boolean
operations
    pressLiftButton(label : String)
    openDoor()
    closeDoor()
    engageEmergencyBreak()
    unlockDoor()
    unlockMovement()
    tick()
end

---- ASSOCIATIONS ----

association CanGoToFloor between
    Lift[0..*] role lift
    Floor[0..*] role floorOptions
end

association CanCallLift between
    Floor[0..*] role _floor
    Lift[0..*] role liftOptions
end

association Floors between
    Building[1] role buildingFloorOwner
    Floor[2..*] role floorsInBuilding
end

association Lifts between
    Building[1] role buildingLiftOwner
    Lift[1..*] role liftsInBuilding
end

constraints

---- INVARIANTS ----

context Lift
    inv doorsMustBeClosedToMove:
        not(physicalMovement=Movement::idle)implies(doorsClosed=true)
    inv lockedDoorCantOpen:
        (lockDoor)implies(doorsClosed=true)
    inv cantMoveIfLocked:
        (movementLocked)implies(jobMovement=Movement::idle and physicalMovement=Movement::idle and jobs=Set{})
--  TODO add invariant must have direction if job queue non empty

context Building
    inv topLevelCanOnlyGoDown :
        floorsInBuilding->forAll(
            floor1 : Floor |
            not(floorsInBuilding->exists(floor2 : Floor | floor2.level > floor1.level))
            implies
            (floor1.buttons=Set{FloorButtonDirection::down})
        )
    inv bottomLevelCanOnlyGoUP :
        floorsInBuilding->forAll(
            floor1 : Floor |
            not(floorsInBuilding->exists(floor2 : Floor | floor2.level < floor1.level))
            implies
            (floor1.buttons=Set{FloorButtonDirection::up})
        )
    inv middleFloorCanGoUpAndDown :
        floorsInBuilding->forAll(
            floor1 : Floor |
            (floorsInBuilding->exists(floor2 : Floor | floor2.level > floor1.level)
                and floorsInBuilding->exists(floor3 : Floor | floor3.level < floor1.level)
            )
            implies
            (floor1.buttons=Set{FloorButtonDirection::down, FloorButtonDirection::up})
        )

---- METHODS ----

-- Floor button actions

context Floor::pressFloorButton(direction : FloorButtonDirection)
    pre buttonIsOnFloor: buttons->includes(direction)
    post movingUpSoAddJobToClosestUpwardsMovingLift:
        let shortlistLifts:Set(Lift) = (liftOptions->select(lift : Lift | lift.jobMovement=Movement::upward) -- Lifts moving up
                ->intersection(liftOptions->select(lift : Lift | lift.level <= self.level))) -- Lifts below
                ->union(liftOptions->select(lift : Lift | lift.jobMovement=Movement::idle)) -- Idle lifts
        in
        (direction=FloorButtonDirection::up)
        implies
            ((not(shortlistLifts->isEmpty()))implies(
                liftOptions->exists(lift1 : Lift | shortlistLifts->includes(lift1) and
                    not(shortlistLifts->exists(
                        lift2 : Lift | (lift2.level - level).abs() < (lift1.level - level).abs()
                    )) and
                    lift1.jobs->includes(self)
                )
            )) and
            ((shortlistLifts->isEmpty())implies(self.waitingFor=Movement::upward))
    post movingDownSoAddJobToClosestDownwardMovingLift:
        let shortlistLifts:Set(Lift) = (liftOptions->select(lift : Lift | lift.jobMovement=Movement::downward) -- Lifts moving down
                ->intersection(liftOptions->select(lift : Lift | lift.level >= self.level))) -- Lifts above
                ->union(liftOptions->select(lift : Lift | lift.jobMovement=Movement::idle)) -- Idle lifts
        in
        (direction=FloorButtonDirection::down)
        implies
            ((not(shortlistLifts->isEmpty()))implies(
                liftOptions->exists(lift1 : Lift | shortlistLifts->includes(lift1) and
                    not(shortlistLifts->exists(
                        lift2 : Lift | (lift2.level - level).abs() < (lift1.level - level).abs()
                    )) and
                    lift1.jobs->includes(self)
                )
            )) and
            ((shortlistLifts->isEmpty())implies(self.waitingFor=Movement::downward))

-- Lift button actions

context Lift::pressLiftButton(label : String)
    pre floorLabelExists: floorOptions->exists(_floor : Floor | _floor.label = label)
    pre floorIsAboveIfUpwards:
        (jobMovement=Movement::upward)
        implies
        (floorOptions->exists(_floor: Floor | _floor.label=label and _floor.level >= level))
    pre floorIsBelowIfDownwards:
        (jobMovement=Movement::downward)
        implies
        (floorOptions->exists(_floor: Floor | _floor.label=label and _floor.level <= level))
    post addFloorToJobQueue:
        not(floorOptions->exists(_floor: Floor | _floor.label=label and _floor.level = level))
        implies
        (jobs->exists(_floor : Floor | _floor.label = label and floorOptions->includes(_floor)))
    post onSameLevelOpenDoors:
        ((floorOptions->exists(_floor: Floor | _floor.label=label and _floor.level = level))
            and
            (physicalMovement=Movement::idle)
        )
        implies
        (doorsClosed=false)

context Lift::openDoor()
    pre checkNotMoving: physicalMovement=Movement::idle
    post openDoor: doorsClosed=false

context Lift::closeDoor()
    post openDoor: doorsClosed=true

-- Emergency methods

context Lift::engageEmergencyBreak()
    post liftIsStopped : jobMovement=Movement::idle and physicalMovement=Movement::idle and jobs=Set{}
    post doorIsClosed : doorsClosed=true
    post engageLock : lockDoor=true and movementLocked=true

context Lift::unlockDoor()
    post disengageLock : lockDoor=false

context Lift::unlockMovement()
    post disengageMovementLock : movementLocked=false

context Building::engageFireAlarm()
    post fireAlarmIsOn : fireAlarm=true
    post allLiftsNotMoving :
        liftsInBuilding->forAll(
            lift : Lift | lift.jobMovement=Movement::idle
            and
            lift.physicalMovement=Movement::idle
            and
            lift.jobs=Set{}
        )
    post allLiftDoorsOpen :
        liftsInBuilding->forAll(lift : Lift | lift.lockDoor=false and lift.doorsClosed=false)
    post lockLiftMovement :
        liftsInBuilding->forAll(lift : Lift | lift.movementLocked=true)

context Building::disengageFireAlarm()
    post fireAlarmIsOff : fireAlarm=false
    post allLiftsUnlocked :
        liftsInBuilding->forAll(lift : Lift | lift.movementLocked=false)

-- Lift tick

context Lift::tick()
-- pre todo: doors must be closed, movement direction must be in correct direction
    post liftHasMoved:
        let distanceToMove:Integer = ((jobs@pre->any(floor1 : Floor |
            ((jobMovement=Movement::upward)implies(not(jobs@pre->exists(floor2 : Floor | floor1.level > floor2.level))))
            and
            ((jobMovement=Movement::downward)implies(not(jobs@pre->exists(floor2 : Floor | floor1.level < floor2.level))))
        )).level - (self.level@pre)).abs()
        in
        ((jobMovement=Movement::upward)implies(level = (self.level@pre) + distanceToMove)) and
        ((jobMovement=Movement::downward)implies(level = (self.level@pre) - distanceToMove))
    post openDoorsAndRemoveQueueAndSetMovementsIfArrived:
        let nextJob:Floor = (jobs@pre->any(floor1 : Floor |
            ((jobMovement=Movement::upward)implies(not(jobs@pre->exists(floor2 : Floor | floor1.level > floor2.level))))
            and
            ((jobMovement=Movement::downward)implies(not(jobs@pre->exists(floor2 : Floor | floor1.level < floor2.level))))
        ))
        in
        ((doorsClosed@pre=true and not(jobs@pre->isEmpty()))implies(
            doorsClosed=false and jobs=(jobs@pre)-Set{nextJob} -- todo: remove jobmovement only if queue is empty, then chec for floors with jobs
        ))


--context Building::liftTick()
--    post shiftAllLifts:
--        let minLift:Lift = liftsInBuilding->any(lift1 : Lift |
--            let closestJobDistFloor1:Integer = (lift1.jobs@pre->any(floor1 : Floor |
--                ((lift1.jobMovement=Movement::upward)implies(not(lift1.jobs@pre->exists(floor2 : Floor | floor1.level > floor2.level))))
--                and
--                ((lift1.jobMovement=Movement::downward)implies(not(lift1.jobs@pre->exists(floor2 : Floor | floor1.level < floor2.level))))
--            ).level - lift1.level).abs()
--            in
--            lift1.doorsClosed@pre=true and -- Doors must be closed to count
--            not(lift1.jobs@pre->isEmpty()) and -- Lift must have jobs
--            closestJobDistFloor1<>0 and
--            (not(liftsInBuilding->exists(lift2 : Lift |
--                let closestJobDistFloor2:Integer = (lift2.jobs@pre->any(floor2 : Floor |
--                    ((lift2.jobMovement=Movement::upward)implies(not(lift2.jobs->exists(floor3 : Floor | floor2.level > floor3.level))))
--                    and
--                    ((lift2.jobMovement=Movement::downward)implies(not(lift2.jobs->exists(floor3 : Floor | floor2.level < floor3.level))))
--                ).level - lift2.level).abs()
--                in
--                lift2.doorsClosed@pre=true and -- Doors must be closed to count
--                not(lift2.jobs@pre->isEmpty()) and -- Lift must have jobs
--                closestJobDistFloor2<>0 and
--                closestJobDistFloor2 < closestJobDistFloor1
--            )))
--        )
--        in
--        let calculatedMin:Integer = ((minLift.jobs->any(floor1 : Floor |
--            ((minLift.jobMovement=Movement::upward)implies(not(minLift.jobs->exists(floor2 : Floor | floor1.level > floor2.level))))
--            and
--            ((minLift.jobMovement=Movement::downward)implies(not(minLift.jobs->exists(floor2 : Floor | floor1.level < floor2.level))))
--        )).level - minLift.level@pre).abs()
--        in
--        minLift.level@pre=1 and
--        liftsInBuilding->forAll(lift : Lift |
--            let minimumJobFloor:Floor = lift.jobs@pre->any(floor1 : Floor | not(lift.jobs@pre->exists(floor2 : Floor | floor2.level < floor1.level))),
--                maximumJobFloor:Floor = lift.jobs@pre->any(floor1 : Floor | not(lift.jobs@pre->exists(floor2 : Floor | floor2.level > floor1.level)))
--            in
--            true --and calculatedMin=3
----            ((lift.doorsClosed@pre=true and not(lift.jobs@pre->isEmpty()))implies(
----                ((lift.jobMovement@pre=Movement::upward)implies(--lift.level = lift.level@pre + calculatedMin and
----                    ((minimumJobFloor.level=lift.level)implies(lift.doorsClosed=false and
----                        lift.jobs=lift.jobs@pre-Set{minimumJobFloor} -- TODO: set physical movements and jobmovements if necessary
----                    ))
----                ))
----                and
----                ((lift.jobMovement@pre=Movement::downward)implies(lift.level = lift.level@pre - calculatedMin and
----                    ((maximumJobFloor.level=lift.level)implies(lift.doorsClosed=false and
----                        lift.jobs=lift.jobs@pre-Set{maximumJobFloor}
----                    ))
----                ))
----            ))
--        )